//-----------------------------------------------------------------------
//1. Подсчёт букв в строке
//-----------------------------------------------------------------------
// На вход подается строка состоящая из букв в нижнем регистре. 
// Требуется разработать алгоритм, который сможет вычислить количество вхождений каждой буквы в эту строку. 
// Затем алгоритм должен вернуть строку, в которой каждая буква будет перечислена в алфавитном порядке, с указанием количества её вхождений.

// Формат ввода
// Входное значение может быть пустой строкой.

// "abcbb"

// Формат вывода
// Выходное значение может быть пустой строкой.

// "a:1,b:3,c:1"

function countLetters(str) {
    const letterCounts = {};

    for (const char of str) {
        letterCounts[char] = (letterCounts[char] || 0) + 1;
    }

    const sortedEntries = Object.entries(letterCounts).sort();

    return sortedEntries.map(([letter, count]) => `${letter}:${count}`).join(',');
}

console.log(countLetters("abcbb"))


//-------------------------------------------------------------------------------------
// 2. Касса
//=------------------------------------------------------------------------------------
// Дана касса, в которой имеется определенное количество различных монет и купюр разных номиналов. Номиналы доступных денежных единиц: 1, 5, 10, 50, 100. Требуется написать алгоритм, который будет выдавать указанную сумму наименьшим количеством денежных единиц, доступных в кассе. Если указанная сумма не может быть выдана, алгоритм должен вернуть сообщение об ошибке.

// Формат ввода
// На вход функция принимает строку, где первое значение - сумма, которую надо выдать. После этого через точку с запятой идут пары чисел, разделённых двоеточием, где первое число - это номинал в порядке возрастания, а второе - это кол-во купюр. Входное значение может быть пустой строкой.

// "78;1:7,5:5,10:3,50:6,100:2"

// Формат вывода
// На выход ожидается строка, где указаны номиналы купюр и их количество через запятую в порядке возрастания номинала. Выходное значение может быть пустой строкой.

// "1:3,5:1,10:2,50:1"

// Если не удалось собрать нужно значение, должно выводится сообщение об ошибке - "Error: Not enough money"

function atm(line) {
    if (!line) return "";

    let [sum, denominations] = line.split(';');
    sum = parseInt(sum);
    if (isNaN(sum)) return "Error: Invalid input";

    let available = new Map(
        denominations.split(',').map(pair => {
            let [denomination, count] = pair.split(':').map(Number);
            return [denomination, count];
        })
    );

    let result = new Map();

    let sortedDenominations = Array.from(available.keys()).sort((a, b) => b - a);

    for (let denomination of sortedDenominations) {
        if (sum <= 0) break;
        let count = available.get(denomination);
        let needed = Math.min(Math.floor(sum / denomination), count);
        if (needed > 0) {
            result.set(denomination, needed);
            sum -= denomination * needed;
        }
    }

    if (sum > 0) {
        return "Error: Not enough money";
    }

    let output = Array.from(result.keys()).sort((a, b) => a - b)
        .map(denomination => `${denomination}:${result.get(denomination)}`)
        .join(',');

    return output;
}

console.log(atm("78;1:7,5:5,10:3,50:6,100:2"))


//---------------------------------------------------------------------------------------
// 3. Обход DOM-дерева
//---------------------------------------------------------------------------------------
// Дано дерево DOM-элементов. У каждого элемента есть поле tagName, которое содержит название тега этого элемента, и опциональный массив children, в котором содержатся его дочерние элементы. Дочерних элементов может не быть, тогда поле children отсутствует. Количество дочерних элементов может быть до 10 штук, глубина дерева - не больше 10. Необходимо составить селекторы вида: DIV>DIV>SPAN для всех элементов дерева, и вывести их отсортированными в строке

// Формат ввода
// На вход функция принимает JSON, сериализованный в строку, в котором содержится информация о DOM дереве - корень дерева со вложенными в него потомками. Входное значение не может быть пустой строкой и гарантировано содержит хотя бы один элемент дерева.

// '{"tagName":"ASIDE","children":[{"tagName":"DIV","children":[{"tagName":"SPAN"}]},{"tagName":"DIV"}]}'

// Формат вывода
// На выход ожидается строка, где указаны все селекторы всех элементов дерева через запятую отсортированные как строки в порядке возрастания. Дубли исключены. Выходное значение может быть пустой строкой.

// "ASIDE,ASIDE>DIV,ASIDE>DIV>SPAN"

function getAllSelectors(line) {
    const root = JSON.parse(line);
    const selectors = new Set();

    function generateSelectors(node, currentSelector = '') {
        selectors.add(currentSelector + node.tagName);
        if (node.children) {
            node.children.forEach(child => {
                generateSelectors(child, currentSelector + node.tagName + '>');
            });
        }
    }

    generateSelectors(root);
    return Array.from(selectors).sort().join(',');
}

console.log(getAllSelectors('{"tagName":"ASIDE","children":[{"tagName":"DIV","children":[{"tagName":"SPAN"}]},{"tagName":"DIV"}]}'))


//----------------------------------------------------------------------------------------------------------------------------------
// 4. Билеты на поезд
//----------------------------------------------------------------------------------------------------------------------------------
// Поезд едет по заданному маршруту, проезжая через станции. Выходя на станции, пассажир должен покупать билет, чтобы сесть на следующий поезд и проехать дальше.

// Билет бывает двух типов: 1 тип дает возможность проехать одну станцию и выйти на следующей, 2 тип - проехать 2 станции подряд и выйти через одну. Оба типа билетов имеют одинаковую стоимость в той кассе, где продаются.

// Для каждой i-ой станции есть своя касса продажи билетов и указана цена билета во входном массиве. Например: “5,7,2”, это значит, что на 1 станции билет стоит 5, на второй - 7, на третьей - 2. Путь можно начать с первой или со второй станции.

// Напишите оптимальный алгоритм для поиска минимальной стоимости поездки по всему маршруту. Ограничение по времени выполнения - 100 мс.

// Формат ввода
// На вход подается строка из стоимостей в виде чисел, разделенных запятой. Каждая стоимость может быть в диапазоне от 0 до 1000. Входное значение не может быть пустой строкой и гарантировано содержит хотя бы два числа, но не больше 1000 чисел.

// "16,16,6,21,12,83,56"

// Формат вывода
// Выходное значение не может быть пустой строкой.

// "90"

function minCostClimbingStairs(line) {
    const prices = line.split(',').map(Number);
    let n = prices.length;
    let dp1 = 0; // Это будет dp[i-2]
    let dp2 = 0; // Это будет dp[i-1]

    let i = 2;
    while (i <= n) {
        let currentCost = Math.min(dp2 + prices[i - 1], dp1 + prices[i - 2]);

        dp1 = dp2;
        dp2 = currentCost;

        i++;
    }
    return dp2;
}

const numLine = '712, 227, 75, 287, 586, 628, 240, 932, 792, 581, 552, 168, 804, 648, 303, 433, 316, 937, 784, 27, 647, 528, 202, 127, 875, 832, 639, 64, 579, 287, 402, 144, 752, 314, 791, 90, 784, 459, 409, 45, 4, 353, 963, 932, 168, 948, 675, 302, 668, 880, 845, 487, 973, 404, 535, 148, 54, 960, 332, 221, 583, 551, 410, 51, 746, 55, 642, 145, 464, 460, 819, 191, 923, 103, 360, 35, 484, 881, 393, 797, 324, 610, 629, 937, 386, 777, 162, 973, 408, 424, 150, 875, 335, 244, 282, 944, 878, 490, 45, 556, 425, 501, 36, 296, 84, 724, 960, 556, 271, 205, 911, 713, 948, 462, 389, 977, 927, 961, 963, 793, 365, 609, 765, 192, 379, 370, 926, 717, 753, 69, 335, 754, 817, 206, 725, 519, 817, 610, 735, 172, 213, 334, 608, 939, 646, 406, 156, 388, 886, 608, 932, 733, 515, 244, 348, 550, 762, 10, 376, 647, 232, 369, 230, 142, 668, 214, 211, 25, 560, 152, 709, 706, 734, 406, 892, 188, 943, 400, 782, 252, 537, 57, 99, 916, 209, 452, 257, 74, 614, 373, 305, 855, 808, 330, 871, 988, 73, 269, 723, 676, 353, 780, 520, 656, 205, 164, 37, 206, 669, 151, 903, 383, 638, 744, 604, 350, 28, 388, 385, 845, 531, 454, 875, 539, 308, 920, 774, 844, 295, 262, 378, 982, 634, 258, 562, 635, 189, 270, 349, 983, 967, 35, 151, 580, 337, 239, 944, 631, 80, 65, 404, 310, 209, 596, 843, 566, 286, 954, 716, 557, 925, 514, 11'

console.log(minCostClimbingStairs(numLine))


//--------------------------------------------------------------------------------
//5. Асимптотическая сложность
//--------------------------------------------------------------------------------
// Выберите асимптотическую сложность этого алгоритма:

function algorithm(arr) {
    const n = arr.length;

    let result = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            result += arr[i] * arr[j];
        }
    }

    let power = 1;

    while (power <= n) {
        power *= 2;
    }

    return [result, power / 2];
}


//1) O(nlog(n))
//2) O(n^2) + O(log(n))
//3) O(log(n)) + O(n)
//4) O(n^2) + O(n) 